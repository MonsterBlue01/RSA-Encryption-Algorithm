\documentclass{article}

\title{RSA encryption}

\author{Dongjing Wang}

\date{December 27, 2022}

\begin{document}
\maketitle

\section{Files}
    \begin{enumerate}
        \item[-] \texttt{.gitingore}: Since generally only files related to the program are uploaded, I added .gitignore to let Git ignore the configuration file of VSCode and the binary files generated after compilation.
        \item[-] \texttt{CHANGELOG}: In order to better debug and plan the coding process, I will record every change I make in the CHANGELOG file.
        \item[-] \texttt{functions.cc}: This file contains all the functions needed for RSA encryption and decryption. This file defines them.
        \item[-] \texttt{functions.hh}: This file contains all the functions needed for RSA encryption and decryption. However, this file only declares all the functions used.
        \item[-] \texttt{LICENSE}: Since I want to legally protect my work, I added LICENSE to my repository.
        \item[-] \texttt{main.cc}: This file includes the scheduling of functions and UI construction for all \texttt{functions.hh} files.
        \item[-] \texttt{Makefile}: I have formulated the necessary "rules" in the Makefile to use the "make" file according to the needs of my compiled project
        \item[-] \texttt{NOTE.md}: Many times I will forget some previous ideas, so I created a \texttt{NOTE.md} to write down what should be paid attention to when making changes next time, and what things must be modified next time.
        \item[-] \texttt{Rabin-Miller Algo.jpg}: When I was using regular data types (int, long, long long) I needed to implement many operations by myself. Verifying whether a number is prime is one of them. Since I still can't understand the Rabin-Miller algorithm, I just use a flowchart to implement it step by step. However, since I used the GMP library, this is not as useful as before, but I still keep it.
        \item[-] \texttt{README.md}: This file contains a brief introduction to my project. For example, the introduction of usage and functions.
    \end{enumerate}
\section{Design}
    \subsection{RSA encryption}
        RSA encryption must first generate two super large prime numbers (usually 1024 bits, 2048 bits, or 4096 bits). My program defaults to 4096 bits. I wrote a helper function to achieve this. After this, we need to find $\phi$, which is $(p-1)\times(q-1)$. And n, which is $p\times q$. Since it would be very difficult to do with regular data types (int, long, or long long), after encountering this problem I decided to rewrite the program and use the GMP library for the second pass. After this, we need to find e, which is a number relatively prime to $\phi$. In order to realize the hierarchy as much as possible, I also modularized this part of the code into a function. The last step is to find d, that is, $d = e^{-1}\ \mathrm{mod}\ \phi$. In this way, the variables required by the public key pair and private key pair are all calculated. Of course, if the user indicates that the public key pair required for encryption already exists, the previous steps can be directly skipped. The last step to do is encryption. And before that we also need to convert the string to a 256-base number. Similarly, I used a helper function to perform bit operations. After that we can encrypt this string of numbers. Encryption (the function of) is based on $c = m^e\ \mathrm{mod}\ n$.
    \subsection{RSA decryption}
    \subsection{Other parts in main function}
\section{Discussion}
\end{document}